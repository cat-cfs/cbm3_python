# Copyright (C) Her Majesty the Queen in Right of Canada,
#  as represented by the Minister of Natural Resources Canada

# ---------------------------------------------------------------------------
#
#  Author: MH
#
#  Created on: April 24, 2013
#
#  Purpose: Replicate all the steps of the VisualBuildScript for a complete
#           CBM run (Why? Because I can't get visual build pro to run on the
#           new HP workstation)
#
#  Usage:
#
#
#  Comments:
#
#
#  Updated: History of changes made to the original script
#
#    Who When     What                                   Why
#    --- ----     ----                                   ----
#   Scott Morken, 2013-11-20, Added simulator class, To test some NIR toolbox
#       builds in light of the KF6 extended disturbance accounting issue
#   Lucas Sinclair, 2019-04-09, Added ability to save stdout, To stop flooding
#       the terminal in which we run our simulations.
#
#
# ---------------------------------------------------------------------------
# Import system modules

import os
import shutil
import subprocess
import glob
import re
import xml.etree.ElementTree as ET
from cbm3_python.util import loghelper


class Simulator(object):
    def __init__(self, executablePath, simID, projectPath, CBMRunDir,
                 toolboxPath, stdout_path=None):
        """Defines relevant paths."""
        self.simID = simID
        self.ProjectPath = projectPath
        self.ExecutablePath = executablePath
        self.CBMTemp = CBMRunDir
        self.toolboxPath = toolboxPath
        self.stdout_path = stdout_path

    def call_subprocess_cmd(self, cmd):
        """Call the defined command *cmd* and optionally record the stdout."""
        if self.stdout_path is None:
            subprocess.check_call(cmd)
        else:
            # make a dir for stdout if it's not already present
            if not os.path.exists(os.path.dirname(self.stdout_path)):
                os.makedirs(os.path.dirname(self.stdout_path))
            with open(self.stdout_path, "a") as handle:
                subprocess.check_call(cmd, stdout=handle, stderr=handle)

    def _ignorethese(self, path, name):
        """Use this with the copytree command to control what does and does
        not get copied."""
        # ignore Access database files
        ignorelist = []
        for item in name:
            if (item.lower().find('.mdb') != -1):
                ignorelist.append(item)
        return ignorelist

    def removeCBMProjfile(self, project_path):
        '''
        remove the autogenerated cbmproj file, since the can potentially
        store incorrect path information and can sometimes be troublesome.
        @param project_path the full path to the cbm3 project database
        '''
        cbmprojFile = "{}.cbmproj".format(os.path.splitext(project_path)[0])
        if os.path.exists(cbmprojFile):
            os.remove(cbmprojFile)

    def setDefaultArchiveIndexPath(self, path):
        '''
        sets the default archive index path for the installed toolbox,
        which is stored in an XML file, to the specified path
        @param path the new default archive index path
        '''
        for config_file in ["Global.cbmproj", "CBMToolbox.xml"]:
            xmlPath = os.path.join(self.toolboxPath, config_file)
            tree = ET.parse(xmlPath)
            root = tree.getroot()
            ArchiveIndexDbPath = root[0].find("ArchiveIndexDbPath")
            ArchiveIndexDbFileName = root[0].find("ArchiveIndexDbFileName")
            ArchiveIndexDbPath.set("value", os.path.dirname(path))
            ArchiveIndexDbFileName.set("value", os.path.basename(path))
            tree.write(xmlPath)

    def getDefaultArchiveIndexPath(self):
        '''
        returns the default archive index path for the installed toolbox,
        which is stored in an XML file
        '''
        xmlPath = os.path.join(self.toolboxPath, "Global.cbmproj")
        tree = ET.parse(xmlPath)
        root = tree.getroot()
        return os.path.join(
            root[0].find("ArchiveIndexDbPath").get("value"),
            root[0].find("ArchiveIndexDbFileName").get("value"))

    def getDefaultProjectResultsPath(self):
        return os.path.join(
            self.ProjectPath, str(self.simID))

    def getDefaultResultsPath(self):
        return os.path.join(
            self.getDefaultProjectResultsPath(), str(self.simID)+'.mdb')

    def CleanupRunDirectory(self):
        loghelper.get_logger().info(
            "\n\n Clean up previous runs in " + self.CBMTemp + " \n")
        top = self.CBMTemp
        for root, dirs, files in os.walk(self.CBMTemp, topdown=False):
            for f in files:
                os.remove(os.path.join(root, f))
            for d in dirs:
                if os.path.join(root, d) != top:
                    shutil.rmtree(os.path.join(root, d), ignore_errors=1)
                    # ignore_errors is TRUE. This is dangerous, but otherwise
                    # the script fails when it gets to CBMRun

    def CopyToWorkingDir(self, filePath):
        shutil.copy(filePath, self.CBMTemp)

    def CreateEmptyMakelistOuput(self):
        '''
        If the temp/Makelist/output dir does not exist the
        makelistsvloader will crash.
        Workaround for projects that do not run makelist, yet do need to
        run makelistsvlloader (afforestation only projects)
        '''
        os.makedirs(os.path.join(self.CBMTemp, "Makelist", "output"))

    def CreateMakelistFiles(self):
        loghelper.get_logger().info("\n\n Creating make list files...\n")
        cmd = '"' + os.path.join(
            self.toolboxPath, r'createMakelistFiles.exe') \
            + '" ' + str(self.simID)
        loghelper.get_logger().info("Command line: " + cmd)
        self.call_subprocess_cmd(cmd)

    def copyMakelist(self):
        loghelper.get_logger().info(
            "\n\n Copying makelist.exe to Temp dir...\n")
        shutil.copy2(
            os.path.join(self.ExecutablePath, r'Makelist.exe'),
            os.path.join(self.CBMTemp, 'Makelist'))

    def runMakelist(self):
        loghelper.get_logger().info("\n\n Running make list...\n")
        makelist_path = os.path.join(self.CBMTemp, r'Makelist\Makelist.exe')
        cwd = os.getcwd()
        try:
            # makelist is expecting the current directory to be its location
            os.chdir(os.path.dirname(makelist_path))

            cmd = '"' + makelist_path + '" '
            loghelper.get_logger().info("Command line: " + cmd)
            self.call_subprocess_cmd(cmd)
        finally:
            os.chdir(cwd)  # change back to the original working dir

    def loadMakelistSVLS(self):
        loghelper.get_logger().info("\n\n Loading Makelist SVLs...\n")
        cmd = '"' + os.path.join(self.toolboxPath, r'MakelistSVLLoader.exe') \
            + '" ' + str(self.simID)
        loghelper.get_logger().info("Command line: " + cmd)
        self.call_subprocess_cmd(cmd)

    def copyMakelistOutput(self, source_path=None):
        if source_path and not os.path.exists(source_path):
            raise ValueError(
                f"specified makelist output dir does not exist: {source_path}")
        loghelper.get_logger().info("\n\n Copying makelist outputs...\n")
        CBMinpath = os.path.join(self.CBMTemp, r'CBMRun\input')
        if os.path.exists(CBMinpath):
            for f in glob.iglob(os.path.join(CBMinpath, '*')):
                os.remove(f)
        else:
            os.makedirs(CBMinpath)
        if source_path:
            ini_glob = os.path.join(source_path, "*.ini")
        else:
            ini_glob = os.path.join(self.CBMTemp, r'Makelist\output\*.ini')
        for f in glob.iglob(ini_glob):
            shutil.copy2(f, CBMinpath)

    def CopySVLFromPreviousRun(self, previousRunCBMOutputDir):
        linebreak = '\n'
        loghelper.get_logger().info(
            "\n\n Copying svl data from previous CBMRun output dir {0}".format(
                previousRunCBMOutputDir))
        srcPaths = []

        def split(s):
            return re.findall('[\S]+', s)

        previousRunCBMOutputDir = os.path.abspath(previousRunCBMOutputDir)
        for filename in os.listdir(previousRunCBMOutputDir):
            # collect the svl###.dat files
            if filename.startswith("svl") and filename.endswith(".dat"):
                srcPaths.append(
                    os.path.join(previousRunCBMOutputDir, filename))
        for srcpath in srcPaths:
            CBMinpath = os.path.join(self.CBMTemp, r'CBMRun\input')
            newFileName = os.path.join(
                CBMinpath,
                "{0}.ini".format(
                    os.path.splitext(os.path.basename(srcpath))[0]))
            with open(srcpath, 'r') as fInput:
                fInput.readline()  # skip line 1
                with open(newFileName, 'w') as fOutput:
                    fOutput.write("0 0" + linebreak)
                    for srcline in fInput:
                        tokens = split(srcline)
                        line1 = " ".join(tokens[0:5] + ['0'])
                        softwood = " ".join(tokens[5:18])
                        hardwood = " ".join(tokens[18:31])
                        dom = " ".join(tokens[31:45])
                        cset = " ".join(
                            [x for x in tokens[45:55] if x != "-99"])
                        kyotoflags = " ".join(
                            ['0', '1', '1990', '0', '0', '0']
                            if tokens[55:61] == ['0', '0', '0', '0', '0', '0']
                            else tokens[55:61])

                        outlines = [
                            line1, softwood, hardwood, dom, "  ".join(
                                [cset, kyotoflags])]

                        for outline in outlines:
                            fOutput.write(outline + linebreak)
                        fOutput.write(linebreak)  # extra line break

    def CreateCBMFiles(self):
        loghelper.get_logger().info("\n\n Creating CBM files...\n")
        cmd = '"' + os.path.join(
            self.toolboxPath, r'createCBMFiles.exe') + '" ' + str(self.simID)
        loghelper.get_logger().info("Command line: " + cmd)
        self.call_subprocess_cmd(cmd)
        inf = open(
            os.path.join(self.CBMTemp, r'CBMRun\input\indicate.inf'), 'w')
        inf.write('0\n')
        inf.flush()
        inf.close()

    def CopyCBMExecutable(self):
        loghelper.get_logger().info("\n\n Copying CBM.exe to Temp dir...\n")
        shutil.copy2(
            os.path.join(self.ExecutablePath, r'CBM.exe'),
            os.path.join(self.CBMTemp, r'CBMRun'))

    def RunCBM(self):
        loghelper.get_logger().info("\n\n Running CBM...\n")
        cbm_path = os.path.join(self.CBMTemp, r'CBMRun\CBM.exe')
        cwd = os.getcwd()
        try:
            # CBM is expecting the current directory to be its location
            os.chdir(os.path.dirname(cbm_path))
            cmd = '"' + cbm_path + '" '
            loghelper.get_logger().info("Command line: " + cmd)
            self.call_subprocess_cmd(cmd)
        finally:
            os.chdir(cwd)  # change back to the original working dir

    def LoadCBMResults(self, output_path=None):
        loghelper.get_logger().info("\n\n Loading CBM Results...\n")
        results_path = self.getDefaultResultsPath() \
            if output_path is None else os.path.abspath(output_path)

        cmd = '"' + os.path.join(self.toolboxPath, r'LoaderCL.exe') + '" ' \
            + str(self.simID) + ' "' + results_path + '"'
        loghelper.get_logger().info("Command line: " + cmd)
        self.call_subprocess_cmd(cmd)

    def CopyTempFiles(self, output_dir):
        loghelper.get_logger().info(
            "\n\n Copying Tempfiles to Project Directory...\n")
        tempfilepath = os.path.abspath(output_dir)
        shutil.copytree(self.CBMTemp, tempfilepath, ignore=self._ignorethese)

    def DumpMakelistSVLs(self):
        loghelper.get_logger().info("\n\n dumping makelist svls...\n")
        cmd = '"' + os.path.join(self.toolboxPath, r'DumpMakelistSVL.exe') \
            + '" "' + str(self.simID) + ' "'
        loghelper.get_logger().info("Command line: " + cmd)
        self.call_subprocess_cmd(cmd)
